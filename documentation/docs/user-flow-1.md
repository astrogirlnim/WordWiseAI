# User Flow 1: Real-Time Funnel Collaboration

## Goal
Enable marketing team members to collaborate on funnel pages in real time, streamlining team-based copy creation and reviews.

---

## Phase 1: Funnel Document Creation & Goals

### Background/Architecture
- Uses: `components/writing-goals-modal.tsx`, `components/document-container.tsx`, `hooks/use-documents.ts`, `types/writing-goals.ts`, `types/document.ts`
- Documents are created with a title and writing goals (audience, intent, etc.)
- Writing goals are stored in document metadata for downstream AI and UI features

### Steps
- [ ] Add/verify UI for creating a new document (DocumentContainer)
- [ ] Show Writing Goals modal on new document creation
- [ ] Save writing goals and title to Firestore on document creation
- [ ] Ensure document type supports goal metadata

---

## Phase 1.5: AI-Powered Funnel Copy Suggestions

### Background/Architecture
- New/changed files:
  - `functions/generateFunnelSuggestions.ts` (new Cloud Function)
  - `services/ai-service.ts` (add `generateFunnelSuggestions` method)
  - `types/ai-features.ts` (add suggestion types: 'headline', 'subheadline', 'cta', 'outline')
  - `components/ai-sidebar.tsx` (add funnel suggestions section/tab)
  - `components/ai-suggestions.tsx` (render new suggestion types)
  - `hooks/use-ai-suggestions.ts` (subscribe to Firestore suggestions)
- Suggestions are generated by a Cloud Function using OpenAI, based on writing goals and current draft
- Suggestions are stored in Firestore under `/documents/{docId}/suggestions`
- UI displays suggestions in the AI Assistant sidebar, allowing apply/dismiss

### Steps
- [ ] Backend: Implement `generateFunnelSuggestions` Cloud Function
  - [ ] Accepts documentId, writing goals, and current draft
  - [ ] Calls OpenAI with a prompt tailored to goals
  - [ ] Returns JSON with suggestions (headline, subheadline, cta, outline)
  - [ ] Stores suggestions in Firestore
- [ ] Extend `ai-service.ts` to call new function
- [ ] Update `types/ai-features.ts` to support new suggestion types
- [ ] Create/extend `hooks/use-ai-suggestions.ts` to fetch suggestions
- [ ] Update `ai-sidebar.tsx` to show funnel suggestions in a dedicated section/tab
- [ ] Update `ai-suggestions.tsx` to render and handle new suggestion types
- [ ] Allow users to apply/dismiss suggestions; insert applied text at cursor/selection
- [ ] Trigger suggestion generation on document creation and when writing goals change

---

## Phase 2: Real-Time Collaboration & Presence

### Background/Architecture
- Uses: `services/collaboration-service.ts`, `components/document-container.tsx`, `types/user.ts`, `types/document.ts`
- Presence is tracked in Firebase Realtime Database
- UI must show active collaborators (avatars/names/colors)

### Steps
- [x] Subscribe to presence updates for the active document
- [x] Add UI to display active users in the editor (e.g., avatar group)
- [x] Show user color/name in cursor or sidebar
- [x] Ensure presence is updated on join/leave
- [x] Enhanced version tracking with user information

---

## Phase 3: Team Review & Commenting

### Background/Architecture
- Uses: `types/comment.ts`, `components/document-editor.tsx`, `components/document-container.tsx`, Firestore for comment storage
- Comments are anchored to text ranges and can be resolved
- UI must allow adding, viewing, and resolving comments

### Steps
- [ ] Add Firestore collection for comments per document
- [ ] Implement UI for adding comments to selected text
- [ ] Display comments inline or in a sidebar
- [ ] Allow resolving/unresolving comments
- [ ] Sync comments in real time

---

## Phase 4: Document Sharing & Access Control

### Background/Architecture
- Uses: `services/document-service.ts`, `services/user-service.ts`, `types/user.ts`, `components/document-container.tsx`
- Documents can be shared with users/org members
- Access control (edit, comment, view) enforced in backend and UI

### Steps
- [ ] Add UI for inviting users by email/org
- [ ] Store access control list (ACL) in document metadata
- [ ] Enforce permissions in backend (Firestore security rules)
- [ ] Show current collaborators and their permissions
- [ ] Allow owner to change permissions or remove users

---

### Document Sharing & Access Control: Implementation Plan & Checklist

#### Phase 1: Shared Document Discovery
- [x] Update `DocumentService` to fetch documents where `sharedWith` contains the current user's ID/email, and where `isPublic` is `true`.
- [x] Update `useDocuments` to include these documents in the list.
- [x] UI: Add a "Shared with Me" and "Public Documents" section in the document list.
  - Files: `services/document-service.ts`, `hooks/use-documents.ts`, `components/document-container.tsx`

#### Phase 2: Sharing/Invitation UI
- [x] Add a "Share" button in the document UI.
- [x] Modal for entering email(s) and selecting role (editor, commenter, viewer).
- [x] Backend logic to update the `sharedWith` array in Firestore.
- [x] Show current collaborators and their roles.
  - Files: `components/document-container.tsx`, `components/ui/`, `services/document-service.ts`, `types/document.ts`

#### Phase 3: Access Control Enforcement
- [x] Enforce permissions in the UI (disable editing for viewers, etc).
- [x] Enforce permissions in backend (Firestore security rules).
- [x] Show error messages for unauthorized access.
  - Files: `components/document-editor.tsx`, `services/document-service.ts`, `firestore.rules`, `types/document.ts`

#### Phase 4: Public/Link Sharing
- [x] UI to toggle public access and copy shareable link.
- [x] Backend logic to set `isPublic` and `publicViewMode`.
- [x] UI for anonymous/public users to view/comment (if allowed).
  - Files: `components/document-container.tsx`, `components/ui/`, `services/document-service.ts`, `types/document.ts`, `firestore.rules`

#### Phase 5: Manage & Remove Access
- [x] UI to change collaborator roles or remove them.
- [x] Backend logic to update `sharedWith` array.
- [x] Notifications for users when access changes.
  - Files: `components/share-dialog.tsx`, `components/navigation-bar.tsx`, `services/document-service.ts`

---

#### Variables & Data Structures
- `Document.sharedWith: DocumentAccess[]` — list of users with access and their roles.
- `Document.isPublic: boolean` — whether the document is public.
- `Document.publicViewMode: 'view' | 'comment' | 'disabled'` — public access level.
- `Document.ownerId: string` — document owner.
- `DocumentAccess.role: 'owner' | 'editor' | 'commenter' | 'viewer'` — user role.

---

#### Checklist for Implementation
- [x] Update backend and hooks to support shared/public document discovery.
- [x] Build sharing/invitation UI.
- [x] Enforce access control in UI and backend.
- [x] Add public/link sharing features.
- [x] Add collaborator management UI.

---

### Document Sharing & Access Control: Implementation Summary

**Phase 1: Shared Document Discovery**
- `services/document-service.ts`: Added `getSharedDocuments` and `getPublicDocuments` methods using `sharedWithIds` and `isPublic` fields.
- `hooks/use-documents.ts`: Subscribes to owned, shared, and public documents; merges and sorts for UI.
- `components/enhanced-document-list.tsx`: Renders "Shared with Me" and "Public Documents" sections in the document list UI.
- Confirmed: Document discovery and categorization logic is functional and present.

**Phase 2: Sharing/Invitation UI**
- `components/share-dialog.tsx`: New dialog for inviting users by email, selecting role, and managing collaborators.
- `components/navigation-bar.tsx`: Added "Share" button to open the dialog; integrated handlers for sharing, role update, and removal.
- `services/user-service.ts`: Added `findUserByEmail` for user lookup by email.
- `services/document-service.ts`: Added `shareDocument`, `updateUserRole`, and `removeUserAccess` methods for backend sharing logic.
- `components/document-container.tsx`: Now accepts an optional `documentId` prop for direct document loading.
- `app/doc/[documentId]/page.tsx`: New dynamic route for direct document access via link.
- `next.config.mjs`: Removed `output: 'export'` to enable dynamic routing in production.
- Observed: All sharing UI and backend logic is functional; document links work; dialog displays collaborators and roles; backend updates Firestore ACL fields.

**Phase 3: Access Control Enforcement**

**UI Permission Enforcement:**
- `components/document-container.tsx`: 
  - Added `activeDocument` memoization for consistent document reference
  - Implemented `userRole` and `canEdit` logic using `useMemo` to determine user permissions based on document ownership, shared access, and public settings
  - Added unauthorized access handling with error message display for users who navigate directly to documents they cannot access
  - Updated `DocumentEditor` props to include `isEditable` boolean based on user role
  - Fixed `useAutoSave` implementation to properly handle document content updates
  - Corrected props passed to `NavigationBar`, `AISidebar`, and `VersionHistorySidebar` components

- `components/document-editor.tsx`:
  - Added `isEditable: boolean` prop to `DocumentEditorProps` interface
  - Integrated `isEditable` into `useEditor` hook configuration with `editable: isEditable`
  - Added console logging to track document editability state
  - Editor now properly disables editing for viewers and commenters while allowing full editing for owners and editors

**Backend Permission Enforcement:**
- `firestore.rules`: Completely rewritten with role-based access control
  - Added helper functions: `isOwner()`, `isSharedWith()`, `hasRole()`, `canEdit()`, `canView()`
  - Implemented null-safe property checking to handle documents without `sharedWithIds` or `sharedWith` fields
  - **READ access**: Owners, shared users (any role), or public documents with enabled viewing
  - **WRITE access**: Owners and users with 'editor' role only
  - **CREATE access**: User must be the document owner
  - **DELETE access**: Document owners only
  - Sub-collections (versions, suggestions) inherit parent document permissions
  - Added comprehensive null checks using `'property' in docData` pattern to prevent evaluation errors

**Error Handling & User Experience:**
- Unauthorized document access shows "Document not found" message with explanation
- Firebase evaluation errors resolved by adding proper null checks for optional document properties
- Editor displays read-only state for non-editors without breaking functionality
- Proper error boundaries for permission-denied scenarios

**Technical Challenges Resolved:**
1. **Linter Errors**: Fixed multiple TypeScript interface mismatches between components
2. **Hook Usage**: Corrected `useAutoSave` implementation from object-based to callback-based pattern
3. **Component Props**: Aligned prop definitions across `DocumentEditor`, `NavigationBar`, `AISidebar`, and `VersionHistorySidebar`
4. **Firestore Rules Syntax**: Resolved compilation errors by removing unsupported syntax (ternary operators, `let` keyword)
5. **Property Access Safety**: Added comprehensive null checks to prevent runtime evaluation errors

**Verification Results:**
- ✅ Permission denial confirmed for unauthorized users
- ✅ Read-only mode functional for viewers and commenters  
- ✅ Full editing access for owners and editors
- ✅ Firestore rules successfully deployed and enforced
- ✅ UI gracefully handles unauthorized access attempts
- ✅ No evaluation errors in production Firebase environment

**Files Modified:**
- `components/document-container.tsx` - Role determination and UI access control
- `components/document-editor.tsx` - Editor read-only state implementation  
- `firestore.rules` - Comprehensive backend access control with null safety
- `documentation/docs/user-flow-1.md` - Updated implementation checklist

**Phase 4: Public/Link Sharing**

*   **UI Controls**:
    *   `components/share-dialog.tsx`: Added a "Public Access" section with a `Switch` to toggle `isPublic` and a `Select` to control `publicViewMode` ('view' or 'comment').
    *   `components/navigation-bar.tsx`: Implemented `handleUpdatePublicAccess` to orchestrate the UI changes with the backend service.

*   **Backend Logic**:
    *   `services/document-service.ts`: Created a new `updatePublicAccess` method to update `isPublic` and `publicViewMode` fields in Firestore.
    *   `firestore.rules`: Modified security rules to allow public read access (`get`) without authentication. A new `isPublic()` helper function was added, and the `canView()` function was refactored to check for public status before checking for authentication. This allows anonymous users to view documents shared via a public link.

*   **Permission Handling**:
    *   `components/document-container.tsx`: Refactored the `useMemo` hook that calculates `userRole` and `canEdit`. The new logic correctly handles anonymous (logged-out) users by checking `isPublic` and `publicViewMode` first, assigning the appropriate role ('viewer' or 'commenter'). This fixed a bug where public access was not correctly granted to unauthenticated users.

*   **Verification**:
    *   ✅ Public link sharing can be enabled/disabled from the Share dialog.
    *   ✅ Anonymous users can access public documents via direct URL.
    *   ✅ Permissions (`view` vs. `comment`) are correctly applied for public users.
    *   ✅ Firestore rules prevent unauthorized access while allowing intended public access.

*   **Files Modified**:
    *   `components/share-dialog.tsx`
    *   `components/navigation-bar.tsx`
    *   `services/document-service.ts`
    *   `firestore.rules`
    *   `components/document-container.tsx`
    *   `documentation/docs/user-flow-1.md`

**Phase 5: Manage & Remove Access (Secure Invitation Model)**

*   **Sharing Model Refactor**:
    *   The sharing model has been refactored from direct email invitations to a secure, link-based invitation system. This provides better control and visibility for document owners.

*   **Invitation Link Generation**:
    *   `components/share-dialog.tsx`: The UI has been updated. Instead of directly sharing, entering an email and selecting a role now generates a unique invitation link. This link is displayed to the user to be copied and sent manually. The dialog workflow was also improved to prevent UI jank and clearly separate public access from private invitations.
    *   `services/invitation-service.ts`: A new service was created to handle the logic for creating, fetching, and revoking invitations. It generates a unique token for each invitation and stores it in a new `invitations` collection in Firestore. It also prevents duplicate invitations from being created for the same user.

*   **Invitation Acceptance Flow**:
    *   `app/doc/[documentId]/page.tsx`: This page now checks for an `inviteToken` in the URL.
        *   If the user is logged in, it calls a cloud function to accept the invite.
        *   If the user is not logged in, it saves the token in `localStorage` and redirects them to sign-in.
    *   `lib/auth-context.tsx`: After a user signs in or signs up, the auth context checks for a pending token in `localStorage` and automatically triggers the acceptance flow.
    *   `functions/index.js`: A new `acceptInvite` cloud function was added to securely process the invitation, validate the user, and grant them access to the document.

*   **UI and User Experience**:
    *   The "People with access" list now correctly shows the document owner, active collaborators, and pending invitations.
    *   Document owners can revoke pending invitations directly from the share dialog.
    *   `app/globals.css`: A persistent contrast issue with the UI `Switch` component in light mode was resolved with custom styles.

*   **Backend & Security**:
    *   `firestore.rules`: New security rules were added for the `/invitations` collection to ensure only document owners can manage them. Pathing issues within the rules were also corrected to resolve permission errors.

*   **Files Added/Modified**:
    *   `types/invitation.ts` (new)
    *   `services/invitation-service.ts` (new)
    *   `components/share-dialog.tsx` (refactored)
    *   `functions/index.js` (updated)
    *   `lib/auth-context.tsx` (updated)
    *   `app/doc/[documentId]/page.tsx` (updated)
    *   `firestore.rules` (updated)
    *   `app/globals.css` (updated)
    *   `documentation/docs/user-flow-1.md` (updated)

---

## Phase 6: Review & Approval Workflow

### Background/Architecture
- Uses: `types/document.ts`, `components/document-status-bar.tsx`, `components/document-container.tsx`
- Documents have a status: 'draft', 'review', 'final', 'archived'
- UI must allow status changes and notify collaborators

### Steps
- [ ] Add UI controls to change document status
- [ ] Display current status in the editor/status bar
- [ ] Notify collaborators of status changes (toast, email, etc.)
- [ ] Restrict editing based on status (e.g., 'final' is read-only)

---

## Checklist (per phase)

### Phase 1: Funnel Document Creation & Goals
- [ ] Document creation flow uses Writing Goals modal
- [ ] Goals and title saved to document

### Phase 1.5: AI-Powered Funnel Copy Suggestions
- [ ] Backend Cloud Function for funnel suggestions
- [ ] Suggestion types: headline, subheadline, cta, outline
- [ ] Suggestions stored in Firestore
- [ ] Sidebar UI for funnel suggestions
- [ ] Apply/dismiss suggestion actions
- [ ] Suggestion generation triggers on creation/goals change

### Phase 2: Real-Time Collaboration & Presence
- [x] Presence UI shows active collaborators
- [x] User colors and avatar generation
- [x] Real-time presence subscription
- [x] Join/leave session management
- [x] Enhanced version history with user tracking

### Phase 3: Team Review & Commenting
- [ ] Commenting UI for feedback and discussion

### Phase 4: Document Sharing & Access Control
- [x] Sharing/invitation UI
- [x] Access control logic
- [x] Public/Link Sharing
- [x] Collaborator management UI

### Phase 5: Secure Invitation Model
- [x] Secure, link-based invitation system
- [x] Invitation acceptance flow (frontend and backend)
- [x] UI for revoking pending invitations

### Phase 6: Review & Approval Workflow
- [ ] Status controls and workflow UI
- [ ] Reviewer notifications
  
# User Flow 1: Real-Time Funnel Collaboration

## Goal
Enable marketing team members to collaborate on funnel pages in real time, streamlining team-based copy creation and reviews.

---

## Phase 1: Funnel Document Creation & Goals

### Background/Architecture
- Uses: `components/writing-goals-modal.tsx`, `components/document-container.tsx`, `hooks/use-documents.ts`, `types/writing-goals.ts`, `types/document.ts`
- Documents are created with a title and writing goals (audience, intent, etc.)
- Writing goals are stored in document metadata for downstream AI and UI features

### Steps
- [ ] Add/verify UI for creating a new document (DocumentContainer)
- [ ] Show Writing Goals modal on new document creation
- [ ] Save writing goals and title to Firestore on document creation
- [ ] Ensure document type supports goal metadata

---

## Phase 1.5: AI-Powered Funnel Copy Suggestions

### Background/Architecture
- New/changed files:
  - `functions/generateFunnelSuggestions.ts` (new Cloud Function)
  - `services/ai-service.ts` (add `generateFunnelSuggestions` method)
  - `types/ai-features.ts` (add suggestion types: 'headline', 'subheadline', 'cta', 'outline')
  - `components/ai-sidebar.tsx` (add funnel suggestions section/tab)
  - `components/ai-suggestions.tsx` (render new suggestion types)
  - `hooks/use-ai-suggestions.ts` (subscribe to Firestore suggestions)
- Suggestions are generated by a Cloud Function using OpenAI, based on writing goals and current draft
- Suggestions are stored in Firestore under `/documents/{docId}/suggestions`
- UI displays suggestions in the AI Assistant sidebar, allowing apply/dismiss

### Steps
- [ ] Backend: Implement `generateFunnelSuggestions` Cloud Function
  - [ ] Accepts documentId, writing goals, and current draft
  - [ ] Calls OpenAI with a prompt tailored to goals
  - [ ] Returns JSON with suggestions (headline, subheadline, cta, outline)
  - [ ] Stores suggestions in Firestore
- [ ] Extend `ai-service.ts` to call new function
- [ ] Update `types/ai-features.ts` to support new suggestion types
- [ ] Create/extend `hooks/use-ai-suggestions.ts` to fetch suggestions
- [ ] Update `ai-sidebar.tsx` to show funnel suggestions in a dedicated section/tab
- [ ] Update `ai-suggestions.tsx` to render and handle new suggestion types
- [ ] Allow users to apply/dismiss suggestions; insert applied text at cursor/selection
- [ ] Trigger suggestion generation on document creation and when writing goals change

---

## Phase 2: Real-Time Collaboration & Presence

### Background/Architecture
- Uses: `services/collaboration-service.ts`, `components/document-container.tsx`, `types/user.ts`, `types/document.ts`
- Presence is tracked in Firebase Realtime Database
- UI must show active collaborators (avatars/names/colors)

### Steps
- [x] Subscribe to presence updates for the active document
- [x] Add UI to display active users in the editor (e.g., avatar group)
- [x] Show user color/name in cursor or sidebar
- [x] Ensure presence is updated on join/leave
- [x] Enhanced version tracking with user information

---

## Phase 3: Team Review & Commenting

### Background/Architecture
- Uses: `types/comment.ts`, `components/document-editor.tsx`, `components/document-container.tsx`, Firestore for comment storage
- Comments are anchored to text ranges and can be resolved
- UI must allow adding, viewing, and resolving comments
- See full plan: [`documentation/features/team-review-commenting-phase3.md`](../features/team-review-commenting-phase3.md)

### Phases & Checklist
- [x] **Diagnosis & Verification**
  - [x] Review all comment-related types, stubs, and UI for consistency
  - [x] Verify no duplicate or conflicting comment logic exists
  - [x] Confirm Firestore structure for `/documents/{docId}/comments` is not in use or is safe to extend
  - [x] Audit logging and error handling for all comment flows
- [x] **Firestore Comment Collection**
  - [x] Define `/documents/{docId}/comments` subcollection schema
  - [x] Implement Firestore rules for comment CRUD (owner, editor, commenter roles)
  - [x] Add migration/cleanup script if legacy data exists (skipped, no legacy data)
- [x] **Comment Service & Hook**
  - [x] Implement `services/comment-service.ts` for add, update, resolve, delete, and real-time sync
  - [x] Implement `hooks/use-comments.ts` for real-time state, add/resolve actions, and error handling
  - [x] Add extensive logging for all service/hook actions
- [x] **UI Integration**
  - [x] Implement `components/comments-sidebar.tsx` to display, add, and resolve comments
  - [x] Integrate comment thread anchors and context menus in `components/document-editor.tsx`
  - [x] Pass comment state/handlers via `components/document-container.tsx`
  - [x] Add inline comment indicators and selection logic
  - [x] Ensure real-time updates and optimistic UI
- [x] **Access Control & Security**
  - [x] Update `firestore.rules` for comment subcollection (role-based access)
  - [x] Add UI/UX for permission errors and unauthorized actions (handled via Firestore rules and proper error handling)
  - [x] Test with all user roles (owner, editor, commenter, viewer) (completed with role-based permissions)
- [x] **Diagnosis & Verification (Post-Implementation)**
  - [x] Test end-to-end: add, view, resolve, and delete comments
  - [x] Verify real-time sync and UI updates
  - [x] Audit logs for all comment actions
  - [x] Confirm no duplicate or orphaned comments/threads
  - [x] Review code for modularity, logging, and type safety

#### Relevant Files & Status
- `types/comment.ts`: ✅ Complete
- `services/comment-service.ts`: ✅ Implemented
- `hooks/use-comments.ts`: ✅ Implemented
- `components/comments-sidebar.tsx`: ✅ Implemented
- `components/comment-input-bubble.tsx`: ✅ Implemented
- `components/tiptap-comment-extension.ts`: ✅ Implemented
- `components/document-editor.tsx`: ✅ Integrated
- `components/document-container.tsx`: ✅ Integrated
- `components/navigation-bar.tsx`: ✅ Updated with comments toggle
- `firestore.rules`: ✅ Updated for comments with role-based access control

### Phase 3: Team Review & Commenting - Implementation Summary

**Complete Commenting System Implementation**: Successfully implemented a full-featured commenting system for collaborative document editing with real-time synchronization, role-based permissions, and comprehensive UI/UX.

**Key Features Implemented:**

1. **Backend Infrastructure**:
   - **Firestore Security Rules**: Updated with role-based access control for comment CRUD operations
   - **Comment Service**: Full CRUD operations with real-time subscriptions and proper error handling
   - **Permission System**: Role-based access (owner, editor, commenter, viewer) with proper validation

2. **Real-time Functionality**:
   - **Live Comment Sync**: Real-time comment updates across all connected users
   - **Optimistic UI**: Immediate feedback with proper error handling and rollback
   - **Timestamp Handling**: Robust handling of Firestore timestamps and FieldValue objects

3. **UI Components**:
   - **Comments Sidebar**: Fixed-position sidebar with active/resolved comment sections
   - **Comment Input Bubble**: Elegant floating input with keyboard shortcuts and animations
   - **Tiptap Extension**: Custom extension for comment highlighting and click handlers
   - **Navigation Integration**: Comments toggle button in navigation bar

4. **Advanced Features**:
   - **Text Selection Comments**: Click-and-drag to select text for commenting
   - **Visual Highlights**: Yellow background highlights for commented text with hover effects
   - **Comment Resolution**: Mark comments as resolved/active with proper state management
   - **Delete Functionality**: Comment deletion with proper permission checks
   - **Pagination Support**: Comment positioning works correctly with paginated editor

5. **Technical Implementation**:
   - **Error Handling**: Comprehensive error handling with detailed logging
   - **Type Safety**: Full TypeScript coverage with proper type definitions
   - **Performance**: Efficient real-time subscriptions and optimized rendering
   - **Accessibility**: Proper ARIA labels and keyboard navigation support

**Challenges Resolved**:
- **Timestamp Conversion**: Fixed `toMillis()` errors with FieldValue objects
- **Comment Positioning**: Handled pagination-aware comment positioning
- **Permission Bugs**: Fixed comment author permissions for resolution/reactivation
- **Animation Issues**: Restored smooth sidebar animations
- **Highlight Persistence**: Fixed comment highlights not disappearing when deleted
- **Role-based Access**: Completed sharing integration for proper role-based permissions

**Final Status**: Phase 3 is fully complete with all checklist items implemented and tested. The commenting system is production-ready with comprehensive logging, error handling, and real-time collaboration features.

---

## Phase 4: Document Sharing & Access Control

### Background/Architecture
- Uses: `services/document-service.ts`, `services/user-service.ts`, `types/user.ts`, `components/document-container.tsx`
- Documents can be shared with users/org members
- Access control (edit, comment, view) enforced in backend and UI

### Steps
- [-] Add UI for inviting users by email/org -- OUT OF SCOPE
- [ ] Store access control list (ACL) in document metadata
- [ ] Enforce permissions in backend (Firestore security rules)
- [ ] Show current collaborators and their permissions
- [ ] Allow owner to change permissions or remove users

---

### Document Sharing & Access Control: Implementation Plan & Checklist

#### Phase 1: Shared Document Discovery
- [x] Update `DocumentService` to fetch documents where `sharedWith` contains the current user's ID/email, and where `isPublic` is `true`.
- [x] Update `useDocuments` to include these documents in the list.
- [x] UI: Add a "Shared with Me" and "Public Documents" section in the document list.
  - Files: `services/document-service.ts`, `hooks/use-documents.ts`, `components/document-container.tsx`

#### Phase 2: Sharing/Invitation UI
- [x] Add a "Share" button in the document UI.
- [x] Modal for entering email(s) and selecting role (editor, commenter, viewer).
- [x] Backend logic to update the `sharedWith` array in Firestore.
- [x] Show current collaborators and their roles.
  - Files: `components/document-container.tsx`, `components/ui/`, `services/document-service.ts`, `types/document.ts`

#### Phase 3: Access Control Enforcement
- [x] Enforce permissions in the UI (disable editing for viewers, etc).
- [x] Enforce permissions in backend (Firestore security rules).
- [x] Show error messages for unauthorized access.
  - Files: `components/document-editor.tsx`, `services/document-service.ts`, `firestore.rules`, `types/document.ts`

#### Phase 4: Public/Link Sharing
- [x] UI to toggle public access and copy shareable link.
- [x] Backend logic to set `isPublic` and `publicViewMode`.
- [x] UI for anonymous/public users to view/comment (if allowed).
  - Files: `components/document-container.tsx`, `components/ui/`, `services/document-service.ts`, `types/document.ts`, `firestore.rules`

#### Phase 5: Manage & Remove Access
- [x] UI to change collaborator roles or remove them.
- [x] Backend logic to update `sharedWith` array.
- [x] Notifications for users when access changes.
  - Files: `components/share-dialog.tsx`, `components/navigation-bar.tsx`, `services/document-service.ts`

---

#### Variables & Data Structures
- `Document.sharedWith: DocumentAccess[]` — list of users with access and their roles.
- `Document.isPublic: boolean` — whether the document is public.
- `Document.publicViewMode: 'view' | 'comment' | 'disabled'` — public access level.
- `Document.ownerId: string` — document owner.
- `DocumentAccess.role: 'owner' | 'editor' | 'commenter' | 'viewer'` — user role.

---

#### Checklist for Implementation
- [x] Update backend and hooks to support shared/public document discovery.
- [x] Build sharing/invitation UI.
- [x] Enforce access control in UI and backend.
- [x] Add public/link sharing features.
- [x] Add collaborator management UI.

---

### Document Sharing & Access Control: Implementation Summary

**Phase 1: Shared Document Discovery**
- `services/document-service.ts`: Added `getSharedDocuments` and `getPublicDocuments` methods using `sharedWithIds` and `isPublic` fields.
- `hooks/use-documents.ts`: Subscribes to owned, shared, and public documents; merges and sorts for UI.
- `components/enhanced-document-list.tsx`: Renders "Shared with Me" and "Public Documents" sections in the document list UI.
- Confirmed: Document discovery and categorization logic is functional and present.

**Phase 2: Sharing/Invitation UI**
- `components/share-dialog.tsx`: New dialog for inviting users by email, selecting role, and managing collaborators.
- `components/navigation-bar.tsx`: Added "Share" button to open the dialog; integrated handlers for sharing, role update, and removal.
- `services/user-service.ts`: Added `findUserByEmail` for user lookup by email.
- `services/document-service.ts`: Added `shareDocument`, `updateUserRole`, and `removeUserAccess` methods for backend sharing logic.
- `components/document-container.tsx`: Now accepts an optional `documentId` prop for direct document loading.
- `app/doc/[documentId]/page.tsx`: New dynamic route for direct document access via link.
- `next.config.mjs`: Removed `output: 'export'` to enable dynamic routing in production.
- Observed: All sharing UI and backend logic is functional; document links work; dialog displays collaborators and roles; backend updates Firestore ACL fields.

**Phase 3: Access Control Enforcement**

**UI Permission Enforcement:**
- `components/document-container.tsx`: 
  - Added `activeDocument` memoization for consistent document reference
  - Implemented `userRole` and `canEdit` logic using `useMemo` to determine user permissions based on document ownership, shared access, and public settings
  - Added unauthorized access handling with error message display for users who navigate directly to documents they cannot access
  - Updated `DocumentEditor` props to include `isEditable` boolean based on user role
  - Fixed `useAutoSave` implementation to properly handle document content updates
  - Corrected props passed to `NavigationBar`, `AISidebar`, and `VersionHistorySidebar` components

- `components/document-editor.tsx`:
  - Added `isEditable: boolean` prop to `DocumentEditorProps` interface
  - Integrated `isEditable` into `useEditor` hook configuration with `editable: isEditable`
  - Added console logging to track document editability state
  - Editor now properly disables editing for viewers and commenters while allowing full editing for owners and editors

**Backend Permission Enforcement:**
- `firestore.rules`: Completely rewritten with role-based access control
  - Added helper functions: `isOwner()`, `isSharedWith()`, `hasRole()`, `canEdit()`, `canView()`
  - Implemented null-safe property checking to handle documents without `sharedWithIds` or `sharedWith` fields
  - **READ access**: Owners, shared users (any role), or public documents with enabled viewing
  - **WRITE access**: Owners and users with 'editor' role only
  - **CREATE access**: User must be the document owner
  - **DELETE access**: Document owners only
  - Sub-collections (versions, suggestions) inherit parent document permissions
  - Added comprehensive null checks using `'property' in docData` pattern to prevent evaluation errors

**Error Handling & User Experience:**
- Unauthorized document access shows "Document not found" message with explanation
- Firebase evaluation errors resolved by adding proper null checks for optional document properties
- Editor displays read-only state for non-editors without breaking functionality
- Proper error boundaries for permission-denied scenarios

**Technical Challenges Resolved:**
1. **Linter Errors**: Fixed multiple TypeScript interface mismatches between components
2. **Hook Usage**: Corrected `useAutoSave` implementation from object-based to callback-based pattern
3. **Component Props**: Aligned prop definitions across `DocumentEditor`, `NavigationBar`, `AISidebar`, and `VersionHistorySidebar`
4. **Firestore Rules Syntax**: Resolved compilation errors by removing unsupported syntax (ternary operators, `let` keyword)
5. **Property Access Safety**: Added comprehensive null checks to prevent runtime evaluation errors

**Verification Results:**
- ✅ Permission denial confirmed for unauthorized users
- ✅ Read-only mode functional for viewers and commenters  
- ✅ Full editing access for owners and editors
- ✅ Firestore rules successfully deployed and enforced
- ✅ UI gracefully handles unauthorized access attempts
- ✅ No evaluation errors in production Firebase environment

**Files Modified:**
- `components/document-container.tsx` - Role determination and UI access control
- `components/document-editor.tsx` - Editor read-only state implementation  
- `firestore.rules` - Comprehensive backend access control with null safety
- `documentation/docs/user-flow-1.md` - Updated implementation checklist

**Phase 4: Public/Link Sharing**

*   **UI Controls**:
    *   `components/share-dialog.tsx`: Added a "Public Access" section with a `Switch` to toggle `isPublic` and a `Select` to control `publicViewMode` ('view' or 'comment').
    *   `components/navigation-bar.tsx`: Implemented `handleUpdatePublicAccess` to orchestrate the UI changes with the backend service.

*   **Backend Logic**:
    *   `services/document-service.ts`: Created a new `updatePublicAccess` method to update `isPublic` and `publicViewMode` fields in Firestore.
    *   `firestore.rules`: Modified security rules to allow public read access (`get`) without authentication. A new `isPublic()` helper function was added, and the `canView()` function was refactored to check for public status before checking for authentication. This allows anonymous users to view documents shared via a public link.

*   **Permission Handling**:
    *   `components/document-container.tsx`: Refactored the `useMemo` hook that calculates `userRole` and `canEdit`. The new logic correctly handles anonymous (logged-out) users by checking `isPublic` and `publicViewMode` first, assigning the appropriate role ('viewer' or 'commenter'). This fixed a bug where public access was not correctly granted to unauthenticated users.

*   **Verification**:
    *   ✅ Public link sharing can be enabled/disabled from the Share dialog.
    *   ✅ Anonymous users can access public documents via direct URL.
    *   ✅ Permissions (`view` vs. `comment`) are correctly applied for public users.
    *   ✅ Firestore rules prevent unauthorized access while allowing intended public access.

*   **Files Modified**:
    *   `components/share-dialog.tsx`
    *   `components/navigation-bar.tsx`
    *   `services/document-service.ts`
    *   `firestore.rules`
    *   `components/document-container.tsx`
    *   `documentation/docs/user-flow-1.md`

**Phase 5: Manage & Remove Access (Secure Invitation Model)**

*   **Sharing Model Refactor**:
    *   The sharing model has been refactored from direct email invitations to a secure, link-based invitation system. This provides better control and visibility for document owners.

*   **Invitation Link Generation**:
    *   `components/share-dialog.tsx`: The UI has been updated. Instead of directly sharing, entering an email and selecting a role now generates a unique invitation link. This link is displayed to the user to be copied and sent manually. The dialog workflow was also improved to prevent UI jank and clearly separate public access from private invitations.
    *   `services/invitation-service.ts`: A new service was created to handle the logic for creating, fetching, and revoking invitations. It generates a unique token for each invitation and stores it in a new `invitations` collection in Firestore. It also prevents duplicate invitations from being created for the same user.

*   **Invitation Acceptance Flow**:
    *   `app/doc/[documentId]/page.tsx`: This page now checks for an `inviteToken` in the URL.
        *   If the user is logged in, it calls a cloud function to accept the invite.
        *   If the user is not logged in, it saves the token in `localStorage` and redirects them to sign-in.
    *   `lib/auth-context.tsx`: After a user signs in or signs up, the auth context checks for a pending token in `localStorage` and automatically triggers the acceptance flow.
    *   `functions/index.js`: A new `acceptInvite` cloud function was added to securely process the invitation, validate the user, and grant them access to the document.

*   **UI and User Experience**:
    *   The "People with access" list now correctly shows the document owner, active collaborators, and pending invitations.
    *   Document owners can revoke pending invitations directly from the share dialog.
    *   `app/globals.css`: A persistent contrast issue with the UI `Switch` component in light mode was resolved with custom styles.

*   **Backend & Security**:
    *   `firestore.rules`: New security rules were added for the `/invitations` collection to ensure only document owners can manage them. Pathing issues within the rules were also corrected to resolve permission errors.

*   **Files Added/Modified**:
    *   `types/invitation.ts` (new)
    *   `services/invitation-service.ts` (new)
    *   `components/share-dialog.tsx` (refactored)
    *   `functions/index.js` (updated)
    *   `lib/auth-context.tsx` (updated)
    *   `app/doc/[documentId]/page.tsx` (updated)
    *   `firestore.rules` (updated)
    *   `app/globals.css` (updated)
    *   `documentation/docs/user-flow-1.md` (updated)

**Phase 5.1: Bugfixes for Invitation and Collaboration Flow**

*   **Invitation Acceptance & Redirect Bugfix**:
    *   **Problem**: After signing in from an invitation link, users were not redirected to the document. The `acceptInvite` cloud function was also failing silently.
    *   **Root Cause**: The `acceptInvite` function had multiple critical errors:
        1.  It was using `admin.firestore.FieldValue.serverTimestamp()` and `admin.firestore.FieldValue.arrayUnion()` incorrectly, causing `TypeError` exceptions.
        2.  A Firestore security rule violation occurred because `FieldValue.serverTimestamp()` was being used inside an array update (`arrayUnion`), which is not allowed.
    *   **Solution**:
        *   Corrected the function to import `FieldValue` from `firebase-admin/firestore` and use it directly (e.g., `FieldValue.serverTimestamp()`).
        *   Replaced the server timestamp in the array update with a client-side timestamp (`Date.now()`) to prevent the Firestore error.
        *   Enhanced the frontend `lib/auth-context.tsx` to reliably redirect the user to the correct document after the invitation is successfully accepted.
    *   **Files Modified**: `functions/index.js`, `lib/auth-context.tsx`.

*   **Real-time Collaboration Permission Bugfix**:
    *   **Problem**: Newly invited users could not join the collaboration session and would get a `PERMISSION_DENIED` error from the Realtime Database.
    *   **Root Cause**: The Realtime Database rules only granted access to the document owner, not to users who were shared on the document.
    *   **Solution**:
        *   Updated `database.rules.json` to allow access if a user's ID is present in a `sharedUserIds` map in the document's metadata.
        *   Modified `services/collaboration-service.ts` so that when a user joins a session, it writes the list of shared user IDs to the Realtime Database metadata, allowing the new rules to grant access.
    *   **Files Modified**: `database.rules.json`, `services/collaboration-service.ts`.

*   **Sign-Out Error Bugfix**:
    *   **Problem**: Users would receive a `PERMISSION_DENIED` error when signing out of a document they were collaborating on.
    *   **Root Cause**: A race condition occurred where the user was signed out before they had properly left the collaboration session.
    *   **Solution**:
        *   Refactored the `logout` function in `lib/auth-context.tsx` to gracefully leave the collaboration session *before* completing the sign-out process.
        *   Updated `components/navigation-bar.tsx` to pass the active document ID to the enhanced `logout` function.
        *   Removed the conflicting session cleanup logic from `components/document-container.tsx`.
    *   **Files Modified**: `lib/auth-context.tsx`, `components/navigation-bar.tsx`, `components/document-container.tsx`.

---

## Phase 6: Review & Approval Workflow

### Background/Architecture
- Uses: `types/document.ts`, `components/document-status-bar.tsx`, `components/document-container.tsx`
- Documents have a status: 'draft', 'review', 'final', 'archived'
- UI must allow status changes and notify collaborators

### Steps
- [ ] Add UI controls to change document status
- [ ] Display current status in the editor/status bar
- [ ] Notify collaborators of status changes (toast, email, etc.)
- [ ] Restrict editing based on status (e.g., 'final' is read-only)

---

## Phase 7: Dedicated User Management Page

### Background/Architecture
- Motivation: As the number of collaborators and invitations grows, managing users in the Share Dialog becomes unwieldy. A dedicated page is needed for scalable, organized user management.
- Uses: `components/manage-users-page.tsx` (new), `components/user-list.tsx` (new/shared), `components/navigation-bar.tsx`, `components/user-menu.tsx`, `services/invitation-service.ts`, `services/document-service.ts`, `types/invitation.ts`, `types/document.ts`, `firestore.rules`
- Entry: Accessible from the user dropdown menu (like Settings), and optionally from the document UI.

### Steps
- [ ] Create a new page: `app/(main)/manage-users/page.tsx` (or `app/(main)/settings/manage-users/page.tsx` for better organization)
- [ ] Add a "Manage Users" entry to the user dropdown menu (`components/user-menu.tsx`)
- [ ] Move user/collaborator list, role management, and invitation revocation UI from `ShareDialog` to the new page
- [ ] Keep only public link and quick invite in the Share Dialog
- [ ] Extract user list logic/UI into a reusable component (`components/user-list.tsx`) if needed
- [ ] Ensure only owners/editors can access/manage users
- [ ] When accessed from a document, show/manage users for that document; otherwise, show all manageable documents
- [ ] Add navigation and routing logic for seamless access
- [ ] Update documentation and user flow to reflect the new management page

### Files Added/Modified
- `app/(main)/manage-users/page.tsx` (new): Dedicated user management page
- `components/user-list.tsx` (new/shared): User/collaborator list, roles, revoke, pending invites
- `components/share-dialog.tsx`: Remove user list, keep only public link and quick invite
- `components/navigation-bar.tsx`, `components/user-menu.tsx`: Add navigation to Manage Users page
- `services/invitation-service.ts`, `services/document-service.ts`: No major changes, but ensure all logic is reusable
- `types/invitation.ts`, `types/document.ts`: No changes expected
- `firestore.rules`: No changes expected unless new permissions are required

### Summary
A dedicated Manage Users page will provide a scalable, organized interface for managing collaborators, roles, and invitations. This keeps the Share Dialog focused and uncluttered, and ensures best practices for large teams and future growth.

---

## Checklist (per phase)

### Phase 1: Funnel Document Creation & Goals
- [ ] Document creation flow uses Writing Goals modal
- [ ] Goals and title saved to document

### Phase 1.5: AI-Powered Funnel Copy Suggestions
- [ ] Backend Cloud Function for funnel suggestions
- [ ] Suggestion types: headline, subheadline, cta, outline
- [ ] Suggestions stored in Firestore
- [ ] Sidebar UI for funnel suggestions
- [ ] Apply/dismiss suggestion actions
- [ ] Suggestion generation triggers on creation/goals change

### Phase 2: Real-Time Collaboration & Presence
- [x] Presence UI shows active collaborators
- [x] User colors and avatar generation
- [x] Real-time presence subscription
- [x] Join/leave session management
- [x] Enhanced version history with user tracking

### Phase 3: Team Review & Commenting
- [x] Complete commenting system for feedback and discussion
- [x] Real-time comment synchronization and UI updates
- [x] Role-based permissions and access control
- [x] Comment resolution and reactivation functionality
- [x] Text selection-based commenting with visual highlights
- [x] Comprehensive error handling and logging

### Phase 4: Document Sharing & Access Control
- [x] Sharing/invitation UI
- [x] Access control logic
- [x] Public/Link Sharing
- [x] Collaborator management UI

### Phase 5: Secure Invitation Model
- [x] Secure, link-based invitation system
- [x] Invitation acceptance flow (frontend and backend)
- [x] UI for revoking pending invitations

### Phase 6: Review & Approval Workflow
- [ ] Status controls and workflow UI
- [ ] Reviewer notifications

### Phase 7: Dedicated User Management Page
- [ ] Manage Users page creation
- [ ] User list extraction and UI
- [ ] Public link and quick invite in Share Dialog
- [ ] User role management
- [ ] Invitation revocation
  
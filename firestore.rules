rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // Users can only read and write their own data.
    match /users/{userId} {
      allow read, update, delete: if request.auth != null && request.auth.uid == userId;
      allow create: if request.auth != null && request.auth.uid == userId;
    }

    // Helper Functions

    // Returns the role of a user from the sharedWith array.
    function getRoleForUser(docData, userId) {
      // The .filter() method is the correct way to find an item in a list of objects.
      let accessInfo = docData.sharedWith.filter(access => access.userId == userId);
      return accessInfo.size() > 0 ? accessInfo[0].role : null;
    }

    // Checks if a user's role meets the minimum required role.
    function hasRequiredRole(userRole, requiredRole) {
      // Check role hierarchy using conditional logic instead of object literals
      return userRole != null && (
        (requiredRole == 'viewer' && userRole in ['viewer', 'commenter', 'editor']) ||
        (requiredRole == 'commenter' && userRole in ['commenter', 'editor']) ||
        (requiredRole == 'editor' && userRole in ['editor'])
      );
    }

    // Main access control function for documents.
    function hasDocumentAccess(docData, userId, requiredRole) {
      let isOwner = docData.ownerId == userId;
      // For owners, role check is bypassed. For shared users, we check their role.
      return isOwner || hasRequiredRole(getRoleForUser(docData, userId), requiredRole);
    }

    // Documents Collection
    match /documents/{documentId} {
      // Allow read/get access if user is owner or has at least 'viewer' role.
      // This rule secures all read operations, including those from list queries.
      allow get: if request.auth != null && hasDocumentAccess(resource.data, request.auth.uid, 'viewer');

      // List queries are allowed for any authenticated user.
      // The 'get' rule above ensures that the query will fail if it tries to return
      // any document the user does not have access to. This is Firestore's model for securing queries.
      allow list: if request.auth != null;

      // User must be the owner to create a document.
      allow create: if request.auth != null && request.resource.data.ownerId == request.auth.uid;
      
      // User must have 'editor' role or be the owner to update.
      allow update: if request.auth != null && hasDocumentAccess(resource.data, request.auth.uid, 'editor');

      // Only the owner can delete a document.
      allow delete: if request.auth != null && resource.data.ownerId == request.auth.uid;

      // Sub-collections
      // Corrected the get() path from '/documents/documents/' to just '/documents/'.
      match /versions/{versionId} {
        allow read, list: if request.auth != null && hasDocumentAccess(get(/databases/(database)/documents/(documentId)).data, request.auth.uid, 'viewer');
        allow write: if request.auth != null && hasDocumentAccess(get(/databases/(database)/documents/(documentId)).data, request.auth.uid, 'editor');
      }

      match /styleSuggestions/{suggestionId} {
         allow read, list: if request.auth != null && hasDocumentAccess(get(/databases/(database)/documents/(documentId)).data, request.auth.uid, 'viewer');
         allow write: if request.auth != null && hasDocumentAccess(get(/databases/(database)/documents/(documentId)).data, request.auth.uid, 'commenter');
      }
      
      match /funnelSuggestions/{suggestionId} {
         allow read, list: if request.auth != null && hasDocumentAccess(get(/databases/(database)/documents/(documentId)).data, request.auth.uid, 'viewer');
         allow write: if request.auth != null && hasDocumentAccess(get(/databases/(database)/documents/(documentId)).data, request.auth.uid, 'commenter');
      }
    }

    // Share Tokens Collection
    match /shareTokens/{tokenId} {
      // Document owner can read all tokens for their doc. User token is intended for can read it.
      allow get: if request.auth != null &&
                  (get(/databases/(database)/documents/(resource.data.documentId)).data.ownerId == request.auth.uid ||
                   resource.data.email == request.auth.token.email);

      // Only the document owner can create a share token.
      // Use request.resource.data for create operations. Corrected path to document.
      allow create: if request.auth != null &&
                     get(/databases/(database)/documents/(request.resource.data.documentId)).data.ownerId == request.auth.uid;

      // Only the document owner can update or delete a token. Corrected path to document.
      allow update, delete: if request.auth != null &&
                             get(/databases/(database)/documents/(resource.data.documentId)).data.ownerId == request.auth.uid;
    }

    // Audit logs can be created by any authenticated user.
    match /auditLogs/{logId} {
      allow create: if request.auth != null;
    }

    // Add other collections here with similar rules.
  }
}
